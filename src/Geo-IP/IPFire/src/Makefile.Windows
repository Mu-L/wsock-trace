#
# GNU Makefile for libloc. Supporting MinGW, MSVC or clang-cl.
#
# By G. Vanem <gvanem@yahoo.no> 2020 - 2022.
#
# Ref: https://git.ipfire.org/pub/git/location/libloc.git
#      https://location.ipfire.org/how-to-use
#
# From 'configure.ac':
#
LIBLOC_MAJOR = 0
LIBLOC_MINOR = 9
LIBLOC_MICRO = 11
VERSION      = $(LIBLOC_MAJOR).$(LIBLOC_MINOR).$(LIBLOC_MICRO)

DATE_STAMP = $(shell date.exe +%d-%B-%Y)
MINGW_ROOT = $(realpath $(MINGW32))
THIS_FILE  = $(firstword $(MAKEFILE_LIST))

#
# Used in generated Python scripts.
# This becomes the default database and .pem directory.
#
DATABASE_DIR = $(realpath .)

#
# Use CRT debug (and 'ENABLE_DEBUG').
#
USE_CRT_DEBUG ?= 0

#
# Use Winsock-trace library, MSVC or clang-cl only.
#
USE_WSOCK_TRACE ?= 0

#
# Use OpenSSL?
#
# Otherwise just fake it in a non-obstructive way:
# any macro in 'fake-OpenSSL/openssl/fake-it.h' will cause a
# signature operation in 'test-signature.exe' to fail.
#
USE_OPENSSL  ?= 0
OPENSSL_ROOT ?= f:/MinGW32/src/inet/Crypto/OpenSSL

#
# For C-preprocessing.
#
USE_CLANG_FORMATER ?= 1

#
# Set 'USE_STATIC_LIBLOC=1' to link with '$(STATIC_LIB)' for the test programs.
# Otherwise link to '$(IMPORT_LIB)'.
#
USE_STATIC_LIBLOC ?= 1

#
# Warn on undefined variables.
#
MAKEFLAGS += --warn-undefined-variables

define Usage

  Usage: "$(MAKE) -f $(THIS_FILE) CC=[gcc | cl | clang-cl] [all | clean | realclean]"
  Specify CC=gcc      for MinGW
  Specify CC=cl       for MSVC
  Specify CC=clang-cl for clang-cl
endef

TEST_PROGS = test-address.exe      \
             test-as.exe           \
             test-country.exe      \
             test-database.exe     \
             test-libloc.exe       \
             test-network.exe      \
             test-network-list.exe \
             test-signature.exe    \
             test-stringpool.exe

export CL=

ifeq ($(CC),gcc)
  OBJ_DIR   = MinGW_obj
  MSVC_TYPE = 0

else ifeq ($(CC),cl)
  OBJ_DIR   = MSVC_obj
  MSVC_TYPE = 1

else ifeq ($(CC),clang-cl)
  OBJ_DIR   = clang_obj
  MSVC_TYPE = 1
else
  $(error $(Usage))
endif

PY_D =

ifeq ($(CC),gcc)
  CFLAGS  = -m32 -O2 -g
  LDFLAGS = -m32 -Wl,--print-map,--sort-common,--cref
  RCFLAGS = -O COFF -D__MINGW32__ --target=pe-i386
  O = o

  STATIC_LIB = libloc.a
  IMPORT_LIB = libloc.dll.a

else
  CFLAGS = -nologo -Zi -GS-           \
           -D_CRT_SECURE_NO_WARNINGS  \
           -D_CRT_NONSTDC_NO_WARNINGS \
           -D_CRT_OBSOLETE_NO_WARNINGS

  LDFLAGS = -debug -map -verbose -nologo -incremental:no -nodefaultlib:uuid.lib
  RCFLAGS = -nologo
  O = obj

  STATIC_LIB = libloc.lib
  IMPORT_LIB = libloc_imp.lib

  ifeq ($(CC),clang-cl)
    RCFLAGS += -D__clang__
  else
    RCFLAGS += -D_MSC_VER
  endif

  ifeq ($(USE_CRT_DEBUG),1)
    CFLAGS += -MDd -RTCu -RTCs    \
              -D_CRTDBG_MAP_ALLOC \
              -DENABLE_DEBUG      \
              -FIcrtdbg.h
    PY_D    = _d
  else
    CFLAGS += -MD -Ot
  endif
endif

#
# What to build:
#
TARGETS = $(STATIC_LIB) \
          $(IMPORT_LIB) \
          libloc.dll    \
          $(TEST_PROGS)

CFLAGS += -I. -I./libloc/windows          \
          -DLIBLOC_PRIVATE                \
          -D_WIN32_WINNT=0x601            \
          -DABS_SRCDIR=\"$(realpath ..)\" \
          -DVERSION=\"$(VERSION)\"

ifeq ($(USE_OPENSSL),1)
  CFLAGS += -I$(OPENSSL_ROOT)/include \
            -DUSE_OPENSSL
else
  CFLAGS += -I../../.. -I./fake-OpenSSL
endif

#
# Warning control.
#
ifeq ($(CC),gcc)
  CFLAGS += -Wall                  \
            -Wno-format            \
            -Wno-format-extra-args \
            -Wno-strict-aliasing   \
            -Wno-unused-variable

else ifeq ($(CC),clang-cl)
  CFLAGS += -W4                             \
            -ferror-limit=5                 \
            -Wno-unused-parameter           \
            -Wno-unused-variable            \
            -Wno-visibility                 \
            -Wno-missing-field-initializers \
            -Wno-incompatible-pointer-types
else
  CFLAGS += -W4 -wd4100 -wd4115 -wd4146 -wd4189 -wd4244 -wd4267

  #
  # For warnings such as:
  #   python/database.c(633): warning C4232: nonstandard extension used: 'tp_iter':
  #   address of dllimport 'PyObject_SelfIter' is not static, identity not guaranteed
  #
  CFLAGS += -wd4232
endif

#
# External lib(s) to use for 'libloc.dll'.
# And possibly 'test-*.exe' if 'USE_STATIC_LIBLOC = 1'.
#
ifeq ($(CC),gcc)
  select = $(1)
  WS2_32 = -lws2_32
else
  select = $(2)

  ifeq ($(USE_WSOCK_TRACE),1)
    WS2_32 = wsock_trace.lib
  else
    WS2_32 = ws2_32.lib
  endif
endif

ifeq ($(USE_WSOCK_TRACE),1)
  CFLAGS += -DUSE_WSOCK_TRACE
endif

DNS_LIB = $(call select, -ldnsapi, dnsapi.lib)

ifeq ($(USE_OPENSSL),1)
  OPENSSL_LIBS = $(call select, $(OPENSSL_ROOT)/lib32/libcrypto.dll.a, \
                                $(OPENSSL_ROOT)/lib32/libcrypto_imp.lib)
else
  OPENSSL_LIBS =
endif

LIBLOC_SRC = address.c      \
             as.c           \
             as-list.c      \
             country.c      \
             country-list.c \
             database.c     \
             libloc.c       \
             network.c      \
             network-list.c \
             resolv.c       \
             stringpool.c   \
             writer.c       \
             win_str.c      \
             win_mmap.c

LIBLOC_OBJ = $(addprefix $(OBJ_DIR)/, \
               $(notdir $(LIBLOC_SRC:.c=.$(O))))

PY_SRC = $(addprefix python/, \
           as.c               \
           country.c          \
           database.c         \
           locationmodule.c   \
           network.c          \
           writer.c)

PY_OBJ = $(addprefix $(OBJ_DIR)/py/, \
           $(notdir $(PY_SRC:.c=.$(O))))

all: $(OBJ_DIR) libloc/version.h $(TARGETS) py3_module epilogue

epilogue:
	$(call white_msg, \nWelcome to libloc library and test programs.)
	$(call white_msg, You could do a $(BRIGHT_GREEN)make -f $(THIS_FILE) runtests $(BRIGHT_WHITE)too.)

$(OBJ_DIR) $(OBJ_DIR)/py py3_install py3_install/location:
	- mkdir $@

.SECONDARY: $(OBJ_DIR)/test-address.$(O)      \
            $(OBJ_DIR)/test-as.$(O)           \
            $(OBJ_DIR)/test-country.$(O)      \
            $(OBJ_DIR)/test-database.$(O)     \
            $(OBJ_DIR)/test-libloc.$(O)       \
            $(OBJ_DIR)/test-network.$(O)      \
            $(OBJ_DIR)/test-network-list.$(O) \
            $(OBJ_DIR)/test-stringpool.$(O)   \
            $(OBJ_DIR)/test-signature.$(O)

$(STATIC_LIB): $(OBJ_DIR) $(LIBLOC_OBJ)
	lib -nologo -out:$@ $(LIBLOC_OBJ)
	@echo

ifeq ($(MSVC_TYPE),1)
  DEF_ARG = -def:
endif

$(IMPORT_LIB): libloc.dll

libloc.dll: $(OBJ_DIR)/libloc.def $(LIBLOC_OBJ) $(OBJ_DIR)/libloc.res
	$(call link_DLL, $@, $(DEF_ARG)$^ $(OPENSSL_LIBS) $(DNS_LIB) $(WS2_32), $(IMPORT_LIB))

libloc/version.h: $(THIS_FILE)
	$(call Generate, $@, //)
	$(file >> $@, #ifndef LIBLOC_VERSION_H)
	$(file >> $@, #define LIBLOC_VERSION_H)
	$(file >> $@, #define LIBLOC_MAJOR_VER  $(LIBLOC_MAJOR))
	$(file >> $@, #define LIBLOC_MINOR_VER  $(LIBLOC_MINOR))
	$(file >> $@, #define LIBLOC_MICRO_VER  $(LIBLOC_MICRO))
	$(file >> $@, #endif)

$(OBJ_DIR)/libloc.def: $(STATIC_LIB) $(THIS_FILE)
	$(call Generate, $@, ;)
	@echo -e 'LIBRARY libloc.dll\nEXPORTS'      >> $@
	nm $< | grep ' T _loc_' | sed 's/^.* _/  /' >> $@
	@echo

$(OBJ_DIR)/libloc.rc: $(THIS_FILE)
	$(call Generate, $@, //)
	$(file >> $@, #define RC_FILENAME     "libloc.dll")
	$(file >> $@, #define RC_DESCRIPTION  "A library to determine the location of someone on the Internet.")
	$(file >> $@, $(RC_COMMON))
	@echo

$(OBJ_DIR)/_location.rc: $(THIS_FILE)
	$(call Generate, $@, //)
	$(file >> $@, #define RC_FILENAME     "_location.pyd")
	$(file >> $@, #define RC_DESCRIPTION  "Python3 module for 'libloc.dll'.")
	$(file >> $@, $(RC_COMMON))
	@echo

$(OBJ_DIR)/%.obj: %.c
	$(CC) -c $(CFLAGS) -Fo$@ $<
	@echo

$(OBJ_DIR)/%.o: %.c
	$(CC) -c $(CFLAGS) -o $@ $<
	@echo

%.i: %.c FORCE cpp_filter.py
	$(call C_preprocess, $<, $@, $(C_FORMATER))

FORCE:

cpp_filter.py: $(THIS_FILE)
	$(call green_msg, Generating $@)
	$(file >  $@,#!/usr/bin/env python)
	$(file >> $@,#)
	$(file >> $@,# DO NOT EDIT! This file was generated automatically)
	$(file >> $@,# from $(realpath $<). Edit that file instead.)
	$(file >> $@,#)
	$(file >> $@,from __future__ import print_function)
	$(file >> $@,if 1:)
	$(file >> $@,$(CPP_FILTER_PY))

#
# Must use Python3.
# Use the Python launcher to find the default version 3 Python.
# (which hopefully is not a Cygwin Python that could interfere).
#
# And with 'USE_CRT_DEBUG = 1', use the debug-version of Python3.
#
PYTHON ?= py -3
PY_ROOT = $(subst \,/,$(shell $(PYTHON) -c "import sys; print(sys.prefix)"))

$(OBJ_DIR)/py/%.obj: python/%.c | $(OBJ_DIR)/py
	$(CC) -c $(CFLAGS) -I$(PY_ROOT)/include -Fo$@ $<
	@echo

$(OBJ_DIR)/py/%.o: python/%.c | $(OBJ_DIR)/py
	$(CC) -c $(CFLAGS) -I$(PY_ROOT)/include -o $@ $<
	@echo

$(OBJ_DIR)/%.res: $(OBJ_DIR)/%.rc
	$(call make_res, $@, $<)

ifeq ($(USE_STATIC_LIBLOC),1)
  test-%.exe: $(OBJ_DIR)/test-%.$(O) $(STATIC_LIB)
	$(call link_EXE, $@, $^ $(OPENSSL_LIBS) $(WS2_32))

else
  test-%.exe: $(OBJ_DIR)/test-%.$(O) $(IMPORT_LIB)
	$(call link_EXE, $@, $^ $(WS2_32))
endif

runtests: $(TEST_PROGS)
	for p in $^ ; do                            \
		echo -e "\n\e[1;32mRunning $$p:\e[0m" ; \
		./$$p ;                                 \
		if [ $$? -ne 0 ]; then                  \
			echo -e "\e[1;31mFailed!\e[0m" ;    \
		fi ;                                    \
	done

#
# Rules for building the Python3 module.
#
# Note: there is no 'make install'. So copy manually from './py3_install' to
#       where-ever you like.
#
PY_FILES = $(addprefix python/, \
             database.py        \
             downloader.py      \
             export.py          \
             i18n.py            \
             importer.py        \
             logger.py)

PY_GEN_FILES = $(addprefix py3_install/, \
                 _location.pyd           \
                 location.py             \
                 location-importer.py    \
                 location/__init__.py)

$(PY_GEN_FILES): $(THIS_FILE)

#
# Needed by '_location.pyd'
#
PY_DLL_FILES = libloc.dll

#
# This could be handy for debugging
#
ifneq ($(CC),gcc)
  PY_DLL_FILES += libloc.pdb
endif

py3_module: py3_install py3_install/location $(PY_GEN_FILES) libloc.dll
	cp --update $(PY_DLL_FILES)  py3_install
	cp --update $(PY_FILES)      py3_install/location
	@echo

#
# Hopefully there is only 1 Python library for MinGW matching this:
#
ifeq ($(CC),gcc)
  PY_LIB = $(word 1, $(wildcard $(PY_ROOT)/libs/libpython3*.a))
else
  PY_LIB = $(PY_ROOT)/libs/python3$(PY_D).lib
endif

py3_install/_location.pyd: $(PY_OBJ) $(IMPORT_LIB) $(OBJ_DIR)/_location.res | py3_install
	$(call link_PYD, $@, $(PY_OBJ) $(IMPORT_LIB) $(OBJ_DIR)/_location.res $(PY_LIB))

py3_install/location.py: python/location.in
	$(call green_msg, Generating $@)
	sed -e 's|@VERSION@|$(VERSION)|' -e 's|@databasedir@|$(DATABASE_DIR)|' < $< > $@
	@echo

py3_install/location-importer.py: python/location-importer.in
	$(call green_msg, Generating $@)
	sed -e 's|@VERSION@|$(VERSION)|' -e 's|@databasedir@|$(DATABASE_DIR)|' < $< > $@
	@echo

py3_install/location/__init__.py: python/__init__.py.in
	$(call green_msg, Generating $@)
	sed -e 's|@VERSION@|$(VERSION)|' < $< >> $@
	@echo

clean:
	rm -f *.pdb *.map link.tmp cpp_filter.py libloc/version.h
	rm -fr $(OBJ_DIR)
	@echo

vclean realclean: clean
	rm -fr py3_install
	rm -f $(TARGETS) .depend.Windows

man_doc:  ../man/location.8
html_doc: ../man/location.html

../man/location.xml: ../man/location.txt ../man/asciidoc.conf
	asciidoc -f ../man/asciidoc.conf -d manpage -b docbook -o $@ $<

XSLTPROC_FLAGS = --stringparam man.output.quietly 1          \
                 --stringparam funcsynopsis.style ansi       \
                 --stringparam man.th.extra1.suppress 1      \
                 --stringparam man.authors.section.enabled 1 \
                 --stringparam man.copyright.section.enabled 1

XSLTPROC_FLAGS += http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl

../man/location.8: ../man/location.xml
	xsltproc.exe -o $@ $(XSLTPROC_FLAGS) $<

../man/location.html: ../man/location.txt ../man/asciidoc.conf
	asciidoc.exe -f ../man/asciidoc.conf -b html5 -a icons -a theme=flask -o $@ $<

#
# GNU-make macro:
#
# The following ESC codes assumes you have a MSys/Cygwin 'echo.exe' program with colour support.
#
BRIGHT_GREEN = \e[1;32m
BRIGHT_WHITE = \e[1;37m

colour_msg = @echo -e "$(1)\e[0m"
green_msg  = $(call colour_msg,$(BRIGHT_GREEN)$(strip $(1)))
white_msg  = $(call colour_msg,$(BRIGHT_WHITE)$(strip $(1)))

define Warning
  $(1)
  $(1) DO NOT EDIT! This file was automatically generated
  $(1) from $(realpath $(THIS_FILE)) at $(DATE_STAMP).
  $(1) Edit that file instead.
  $(1)
endef

define Generate
  $(call green_msg, Generating $(1))
  $(file > $(1),$(call Warning,$(strip $(2))))
endef

#
# .$(O) -> .exe macro
#   arg1, $(1): The .exe file.
#   arg2, $(2): The .$(O) file(s), extra options and libs.
#
define link_EXE
  $(call green_msg, Linking $(1))
  $(call link_EXE_$(MSVC_TYPE), $(1), $(2))
  @echo
endef

define link_EXE_0
  $(CC) $(LDFLAGS) -o $(1) $(2) > $(1:.exe=.map)
endef

#
# Remove the .lib/.exp-files due to the pesky 'OPENSSL_Applink' export symbol.
#
define link_EXE_1
  link $(LDFLAGS) -out:$(strip $(1)) $(2) > link.tmp
  @cat link.tmp >> $(1:.exe=.map)
  @rm -f $(1:.exe=.lib) $(1:.exe=.exp)
endef

#
# .$(O) -> .dll macro
#   arg1, $(1): The .dll file.
#   arg2, $(2): The .$(O) file(s), extra options and libs.
#   arg3, $(3): The import library
#
define link_DLL
  $(call green_msg, Linking $(1))
  $(call link_DLL_$(MSVC_TYPE), $(1), $(2), $(3))
  @echo
endef

define link_DLL_0
  $(CC) $(LDFLAGS) -shared -o $(1) -Wl,--out-implib,$(strip $(3)) $(2) > $(1:.dll=.map)
endef

define link_DLL_1
  link $(LDFLAGS) -dll -out:$(strip $(1)) -implib:$(strip $(3)) $(2) > link.tmp
  @cat link.tmp >> $(1:.dll=.map)
  @rm -f $(3:.lib=.exp)
endef

#
# .$(O) -> .pyd macro
#   arg1, $(1): The .pyd file.
#   arg2, $(2): The .$(O) file(s), extra options and libs.
#
define link_PYD
  $(call green_msg, Linking $@)
  $(call link_PYD_$(MSVC_TYPE), $(1), $(2))
  @echo
endef

define link_PYD_0
  $(CC) $(LDFLAGS) -shared -o $(1) $(2) > $(1:.pyd=.map)
endef

define link_PYD_1
  link $(LDFLAGS) -libpath:$(PY_ROOT)/libs -dll -out:$(strip $(1)) $(2) > link.tmp
  @cat link.tmp >> $(1:.pyd=.map)
  @rm -f $(1:.pyd=.lib) $(1:.pyd=.exp)
endef

define make_res
  $(call make_res_$(MSVC_TYPE), $(1), $(2))
  @echo
endef

make_res_0 = windres $(RCFLAGS) -o $(1) -i $(2)
make_res_1 = rc $(RCFLAGS) -Fo $(1) $(2)

ifeq ($(USE_CLANG_FORMATER),1)
  C_FORMATER = | clang-format -style=Mozilla -assume-filename=c
endif

define C_preprocess
  @echo "The result of preprocessing $(strip $(1)) with these CFLAGS:" > $(2)
  @echo $(CFLAGS)                            >> $(2)
  @echo "--------------------------------- " >> $(2)
  $(CC) $(CFLAGS) $(1) -E | $(PYTHON) cpp_filter.py $(3) >> $(2)
endef

define RC_COMMON
  #include <winver.h>

  #define VER_STRING "$(LIBLOC_MAJOR).$(LIBLOC_MINOR).$(LIBLOC_MICRO)"
  #define RC_VERSION  $(LIBLOC_MAJOR),$(LIBLOC_MINOR),$(LIBLOC_MICRO),0

  #ifndef RC_FILENAME
  #error "Add a 'RC_FILENAME' first"
  #endif

  #ifndef RC_DESCRIPTION
  #error "Add a 'RC_DESCRIPTION' first"
  #endif

  #if $(USE_CRT_DEBUG)
    #define DBG_STRING  "x86, debug"
  #else
    #define DBG_STRING  "x86, release"
  #endif

  #if defined(__MINGW32__)
    #define CC_STRING  "MinGW"
  #elif defined(__clang__)
    #define CC_STRING  "clang-cl"
  #else
    #define CC_STRING  "MSVC"
  #endif

  VS_VERSION_INFO VERSIONINFO
    FILEVERSION    RC_VERSION
    PRODUCTVERSION RC_VERSION
    FILEFLAGSMASK  0x3fL
    FILEOS         0x40004L
    FILETYPE       0x2L
    FILESUBTYPE    0x0L
    FILEFLAGS      0x0L

  BEGIN
    BLOCK "StringFileInfo"
    BEGIN
      BLOCK "040904b0"
      BEGIN
        VALUE "CompanyName",      "https://git.ipfire.org/pub/git/location/libloc.git"
        VALUE "FileDescription",  RC_DESCRIPTION
        VALUE "FileVersion",      VER_STRING
        VALUE "InternalName",     "libloc"
        VALUE "LegalCopyright",   "CC BY-SA 4.0."
        VALUE "LegalTrademarks",  "http://www.gnu.org/licenses/"
        VALUE "OriginalFilename", RC_FILENAME
        VALUE "ProductName",      RC_FILENAME
        VALUE "ProductVersion",   VER_STRING " (" CC_STRING ", " DBG_STRING ")"
        VALUE "PrivateBuild",     ""
        VALUE "SpecialBuild",     ""
        VALUE "Comments",         "Built at $(DATE_STAMP)"
      END
    END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x409, 1200
  END
  END
endef

define CPP_FILTER_PY
  import sys, os

  try:
    import ntpath
  except ImportError as e:
    print ("Failed to import ntpath: %s" % e)
    sys.exit(1)

  def _win32_abspath (path):
    path = ntpath.abspath (path)
    return path.replace ('\\', '/')

  def skip_cwd (s1, s2):
    ''' Skip the leading part that is in common with s1 and s2
    '''
    i = 0
    while i < len(s1) and s1[i] == s2[i]:
       i += 1
    return s2[i:]

  cwd = _win32_abspath (os.getcwd()) + '/'

  last_line  = '??'
  last_fname = '??'
  empty_lines = 0

  while True:
    line = sys.stdin.readline()
    if not line:
      break
    if line.startswith('\n') or line.startswith('\r'):
      empty_lines += 1
      continue

    if line.lstrip().startswith("#line"):
      line = line.replace ("\\\\", "/")
    fname = None
    quote = line.find ('\"')

    if line.startswith ("#line ") and quote > 0:
      fname = _win32_abspath (line[quote:])
      last_fname = fname

    if line.strip() != '' and last_line != '':
      if fname is None or fname != last_fname:
        print (line, end="")

      if line.strip() == '}' or line.strip() == '};':  # Print a newline after a functions or structs
        print ("")

    last_line = line

  if empty_lines > 0:
    sys.stderr.write ("Removed %d empty lines.\n" % empty_lines)

endef

DEP_CFLAGS  = -MM $(filter -D% -I%, $(CFLAGS))
DEP_REPLACE = sed -e 's/\(.*\)\.o: /\n$$(OBJ_DIR)\/\1.$$(O): /'

ALL_SOURCES = $(wildcard test-*.c) $(LIBLOC_SRC)

depend:
	$(call Generate, .depend.Windows, #)
	gcc $(DEP_CFLAGS) $(ALL_SOURCES) | $(DEP_REPLACE) >> .depend.Windows

-include .depend.Windows

